# CVE-2019-6329
## Description
In **HP Support Assistant GUI**, when you click **Check for updates and messages**, the service **HP Support Solution Framework** will run some tasks, start HPSAObjUtil8.exe (run as SYSTEM) which changes the permission of all .xml files in **C:\ProgramData\Hewlett-Packard\HP Support Framework\Logs\Temp\HPSA**. In detail, HPSAObjUtil8.exe gives full controls over these .xml files to all users. Following is the vulnerable code in HPSAObjUtil8:
```
public static void AddTempLogsPermission()
	{
		string path = Environment.GetEnvironmentVariable("ProgramData") + "\\Hewlett-Packard\\HP Support Framework\\Logs\\Temp\\HPSA";
		if (Directory.Exists(path))
		{
			**_string[] files = Directory.GetFiles(path, "*.xml");_**
			if (files != null && files.Length != 0)
			{
				foreach (string fileOrFolderName in files)
				{
					**_Patches._utils.AddFileSecurity(fileOrFolderName);_**
				}
			}
		}
	}
```
A user can create a hardlink to a file of our choosing (all we need is read access), then let HPSAObjUtil8 modify the permissions of it so that we can overwrite it.
## Exploitation
By reversing HPSF.exe and HPSupportSolutionsFrameworkService.exe, I figure out that the client HPSF.exe communicates with the service through the interface **HP.SupportFramework.ServiceManager.Interfaces.IServiceInterface** (defined in HP.SupportFramework.ServiceManager.dll). If the client calls the method IserviceInterface.RunAnalysis, the service will start HPSAObjUtil8 and trigger the bug.
```
ServiceInterface.Instance.RunAnalysis("en-US", true);
```
However, the service validates its client before processing the request:
* Check whether the client is signed with HP signature and in C volume.
* Check whether parent, grandparent, great-grandparentâ€¦ of the client is signed with HP signature or is a valid Windows process (in System32, for example). However, if the method GetParent returns null, the checking stops.
```internal static bool \u0001(int \u0002)
        {
            Process processById = Process.GetProcessById(\u0002);
            string text = \u000E.\u0001(processById);
            if (processById.MainModule.FileName.ToLowerInvariant() != text.ToLowerInvariant())
            {
                if (DebugLog.IsDebug)
                {
                    DebugLog.LogDebugMessage("Invalid File detected: " + text, DebugLog.IndentType.None);
                }
                return false;
            }
            Process parent = processById.GetParent();
            bool flag = true;
            int num = 0;
            while (**_parent != null_** && flag && num <= 5)
            {
                bool flag2;
                flag = \u000E.\u0001(parent, out flag2);
                if (!flag || flag2)
                {
                    break;
                }
                num++;
                parent = parent.GetParent();
            }
            return flag;
        }
```
Let's bypass the validation:
* To bypass signature checking, you have to start a HP signed executable and inject code into it, or create some fake dll, and the HP executable loads it up. I find out that BatteryTest.exe (C:\Program Files (x86)\Hewlett-Packard\HP Support Framework\Resources\HPBatteryCheck) is signed with HP signature, and when I start BatteryTest.exe, it tries to load userenv.dll in its directory before searching in %PATH%. So I create a fake userenv.dll and put it in the same folder with BatteryTest.exe, then malicious code can be executed and bypass client signature checking.
* I copy BatterTest.exe and other necessary files into %tmp%, so that they are in C volume.
* To bypass parent checking, I create a program that calls BatteryTest.exe up and exits immediately, so that GetParent returns null!
Now you need to find out an executable that can be the target for the hardlink. I see that when calling RunAnalysis, HPSupportSolutionsFrameworkService starts many processes as SYSTEM. If you overwrite those processes with your own executable, you will get system privileges. However, the service checks signatures of those EXEs before starting them, so you cannot create fake EXEs, but resort to dlls loaded by those EXEs. There are many dlls already loaded somewhere, and many .NET dlls signature-checked before being loaded, so you cannot use them. Luckily, there are still some dlls usable:
* c:\program files (x86)\hp\shared\hputils64.dll, loaded by Detect_BatteryFailure.exe (HP signed).
* c:\windows\syswow64\rtutils.dll
* c:\windows\system32\msxml3.dll
I tried to modify hputils64.dll and succeeded. I create a hardlink to hputils64.dll. When calling RunAnalysis, HPSAObjUtil8 change the hputils64.dll's permissions, then a few seconds later Detect_BatteryFailure.exe starts (as LOCAL SYSTEM) and loads up hputils64.dll. Before hputils64 loaded, you can overwrite it, so that Detect_BatteryFailure.exe loads your malicious malicious dll up and you finally get the SYSTEM right.
## Conclusion
To write the exploit, I created:
* CreateProcess.exe: call up a process and exit.
* CreateHardlink.exe: create hardlink.
* Userenv.dll: set up things for executing .NET assembly and execute the assembly invader.exe.
* Invader.exe: call RunAnalysis which will trigger the bug.
* MalDll.dll: call up notepad. hputils64.dll is overwritten with this dll.
The following is the exploit steps in PrivHP4.py:
1. Copy BatteryTest.exe and other necessary files into %tmp% folder.
2. Create hardlink from **C:\ProgramData\Hewlett-Packard\HP Support Framework\Logs\Temp\HPSA\hardlink.xml** to **C:\Program Files (x86)\HP\Shared\hputils64.dll**
3. Start BatteryTest.exe with CreateProcess.exe
4. Wait for the permission of **C:\Program Files (x86)\HP\Shared\hputils64.dll** to be changed, then overwrite it with MalDll.dll, and then just wait for notepad to start up as SYSTEM!
To test the PoC, just clone the repository and run PrivHP4.py.
