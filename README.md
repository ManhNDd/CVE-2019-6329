#CVE-2019-6329
##Description
In HP Support Assistant GUI, when you click **Check for updates and messages**, the service **HP Support Solution Framework** will run some tasks, start HPSAObjUtil8.exe (run as SYSTEM) which change the permission of all .xml files in **C:\ProgramData\Hewlett-Packard\HP Support Framework\Logs\Temp\HPSA**. In detail, HPSAObjUtil8.exe gives full control over these .xml files to all users. Following is the vulnerable code in HPSAObjUtil8:
```public static void AddTempLogsPermission()
        {
            string path = Environment.GetEnvironmentVariable("ProgramData") + "\\Hewlett-Packard\\HP Support Framework\\Logs\\Temp\\HPSA";
            if (Directory.Exists(path))
            {
                <b>string[] files = Directory.GetFiles(path, "*.xml");</b>
                if (files != null && files.Length != 0)
                {
                    foreach (string fileOrFolderName in files)
                    {
                        <b>Patches._utils.AddFileSecurity(fileOrFolderName);</b>
                    }
                }
            }
        }
```
A user can create a hardlink to a file of our choosing (all we need is read access), then let HPSAObjUtil8 modify the permissions of it so that we can overwrite it. 
##Exploitation
By reversing HPSF.exe and HPSupportSolutionsFrameworkService.exe, I figure out that the client HPSF.exe communicate with the service through the interface HP.SupportFramework.ServiceManager.Interfaces.IServiceInterface (defined in HP.SupportFramework.ServiceManager.dll). If the client call the method IserviceInterface.RunAnalysis, the service will start HPSAObjUtil8 and trigger the bug.
```ServiceInterface.Instance.RunAnalysis("en-US", true);
```
However, the service validates the clients that's using the interface:
* Check whether the client is signed with HP signature and in C volume.
* Check whether parent, grandparent, great-grandparentâ€¦ of the client are signed with HP signature or are valid windows processes (in System32, for example). However, if the method GetParent returns null, the checking stops.
```internal static bool \u0001(int \u0002)
        {
            Process processById = Process.GetProcessById(\u0002);
            string text = \u000E.\u0001(processById);
            if (processById.MainModule.FileName.ToLowerInvariant() != text.ToLowerInvariant())
            {
                if (DebugLog.IsDebug)
                {
                    DebugLog.LogDebugMessage("Invalid File detected: " + text, DebugLog.IndentType.None);
                }
                return false;
            }
            Process parent = processById.GetParent();
            bool flag = true;
            int num = 0;
            while (<b>parent != null</b> && flag && num <= 5)
            {
                bool flag2;
                flag = \u000E.\u0001(parent, out flag2);
                if (!flag || flag2)
                {
                    break;
                }
                num++;
                parent = parent.GetParent();
            }
            return flag;
        }
```
Let's bypass the validation:
* To bypass signature checking for the client, we have to start a HP signed executable and inject code into it, or create some fake dll, and the HP executable loads it up. I find out that BatteryTest.exe (C:\Program Files (x86)\Hewlett-Packard\HP Support Framework\Resources\HPBatteryCheck) is signed with HP signature, and when I start BatteryTest.exe, it tries to load userenv.dll in its directory before searching in %PATH%. So I create a fake userenv.dll and put it in the same folder with BatteryTest.exe, then malicious code can be executed and bypass client signature checking.
* We copy BatterTest.exe and other necessary files into %tmp%, so that they are in C volume.
* To bypass parents checking, we create a program that call BatteryTest.exe up and exit immediately, so that GetParent returns null!
Now we need to find out an executable that can be the target for the hardlink. I see that when calling RunAnalysis, HPSupportSolutionsFrameworkService starts many processes as SYSTEM. The service checks signatures of those EXEs before starting them, so we cannot create fake EXEs, but resort to dlls loaded by those EXEs. However, many dlls are already loaded somewhere, and many .NET dlls are signature-checked before being loaded. Luckily, there are still some dlls that can be used:
* c:\program files (x86)\hp\shared\hputils64.dll, loaded by Detect_BatteryFailure.exe (HP signed).
* c:\windows\syswow64\rtutils.dll
* c:\windows\system32\msxml3.dll
I tried to modify hputils64.dll and succeeded. I create a hardlink to hputils64.dll. When calling RunAnalysis, HPSAObjUtil8 change the hputils64.dll's permissions, then a few seconds later Detect_BatteryFailure.exe start (as LOCAL SYSTEM) and load up hputils64.dll. In those seconds, we can overwrite hputils64.dll, so that Detect_BatteryFailure.exe do malicious things for us.
##Conclusion
To write the exploit, I created:
* CreateProcess.exe: call up a process and exit.
* CreateHardlink.exe: create hardlink.
* Userenv.dll: set up things for executing .NET assembly and execute the assembly invader.exe.
* Invader.exe: call RunAnalysis which will trigger the bug.
* MalDll.dll: call up notepad. hputils64.dll is overwritten with this dll.
The following is the exploit steps in PrivHP4.py:
1. Copy BatteryTest.exe and other necessary files into %tmp% folder.
2. Create hardlink from **C:\ProgramData\Hewlett-Packard\HP Support Framework\Logs\Temp\HPSA\hardlink.xml** to **C:\Program Files (x86)\HP\Shared\hputils64.dll**
3. Start BatteryTest.exe with CreateProcess.exe
4. Wait for the permission of **C:\Program Files (x86)\HP\Shared\hputils64.dll** to be changed, then overwrite it with MalDll.dll, and then just wait for notepad to start up as SYSTEM!
To test the PoC, just clone the repository and run PrivHP4.py.
